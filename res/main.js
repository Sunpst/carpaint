// Generated by IcedCoffeeScript 108.0.9
var HEIGHT, L, WIDTH, animate, c_camera, camera, car, carpaint_mat, controls, create_evironment, environment, init, lights, material, mesh, mime, onWindowResize, render, renderer, rnd, scene, setupControls, shader_loader, sky, sphere_mesh, stats, video_grabber,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

camera = void 0;

c_camera = void 0;

scene = void 0;

renderer = void 0;

mesh = void 0;

material = void 0;

sky = void 0;

controls = void 0;

stats = void 0;

car = void 0;

carpaint_mat = void 0;

sphere_mesh = void 0;

L = 1800;

WIDTH = 960;

HEIGHT = WIDTH / 16 * 9;

mime = 'video/webm';

video_grabber = (function() {
  function video_grabber(canvas) {
    var isSecureOrigin;
    this.canvas = canvas;
    this.download = __bind(this.download, this);
    this.stop_recording = __bind(this.stop_recording, this);
    this.start_recording = __bind(this.start_recording, this);
    this.toggle_recording = __bind(this.toggle_recording, this);
    this.handle_stop = __bind(this.handle_stop, this);
    this.handle_data_available = __bind(this.handle_data_available, this);
    this.handle_source_open = __bind(this.handle_source_open, this);
    this.media_source = new MediaSource;
    this.media_source.addEventListener('sourceopen', this.handle_source_open, false);
    isSecureOrigin = location.protocol === 'https:' || location.hostname === 'localhost';
    if (!isSecureOrigin) {
      alert('getUserMedia() must be run from a secure origin: HTTPS or localhost.' + '\n\nChanging protocol to HTTPS');
      location.protocol = 'HTTPS';
    }
    this.stream = canvas.captureStream();
    console.log('Started @stream capture from canvas element: ', this.stream);
  }

  video_grabber.prototype.handle_source_open = function(event) {
    console.log('MediaSource opened');
    this.sourceBuffer = this.media_source.addSourceBuffer('video/webm; codecs="vp8"');
    return console.log('Source buffer: ', this.sourceBuffer);
  };

  video_grabber.prototype.handle_data_available = function(event) {
    var _ref;
    if (event.data && event.data.size > 0) {
      return (_ref = this.recorded_blobs) != null ? _ref.push(event.data) : void 0;
    }
  };

  video_grabber.prototype.handle_stop = function(event) {
    return console.log('Recorder stopped: ', event);
  };

  video_grabber.prototype.toggle_recording = function() {
    if (recordButton.textContent === 'Start Recording') {
      return startRecording();
    } else {
      stopRecording();
      recordButton.textContent = 'Start Recording';
      playButton.disabled = false;
      return downloadButton.disabled = false;
    }
  };

  video_grabber.prototype.start_recording = function() {
    var e0, e1, e2, options;
    options = {
      mimeType: mime
    };
    this.recorded_blobs = [];
    try {
      this.media_recorder = new MediaRecorder(this.stream, options);
    } catch (_error) {
      e0 = _error;
      console.log('Unable to create MediaRecorder with options Object: ', e0);
      try {
        options = {
          mimeType: "" + mime + ",codecs=vp9"
        };
        this.media_recorder = new MediaRecorder(this.stream, options);
      } catch (_error) {
        e1 = _error;
        console.log('Unable to create MediaRecorder with options Object: ', e1);
      }
      try {
        options = 'video/vp8';
        this.media_recorder = new MediaRecorder(this.stream, options);
      } catch (_error) {
        e2 = _error;
        alert('MediaRecorder is not supported by this browser.\n\n' + 'Try Firefox 29 or later, or Chrome 47 or later, with Enable experimental Web Platform features enabled from chrome://flags.');
        console.error('Exception while creating MediaRecorder:', e2);
      }
    }
    console.log('Created MediaRecorder', this.media_recorder, 'with options', options);
    this.media_recorder.onstop = this.handle_stop;
    this.media_recorder.ondataavailable = this.handle_data_available;
    this.media_recorder.start(100);
    return console.log('MediaRecorder started', this.media_recorder);
  };

  video_grabber.prototype.stop_recording = function() {
    var superBuffer;
    this.media_recorder.stop();
    if (!this.video) {
      this.video = document.createElement("video");
      document.body.appendChild(this.video);
      this.video.controls = true;
    }
    superBuffer = new Blob(this.recorded_blobs, {
      type: mime
    });
    return this.video.src = window.URL.createObjectURL(superBuffer);
  };

  video_grabber.prototype.download = function() {
    var a, blob, url;
    blob = new Blob(this.recorded_blobs, {
      type: mime
    });
    url = window.URL.createObjectURL(blob);
    a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'carpaint.webm';
    document.body.appendChild(a);
    a.click();
    return setTimeout((function() {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }), 100);
  };

  return video_grabber;

})();

shader_loader = function(vertex_url, fragment_url, onLoad, onProgress, onError) {
  var vertex_loader;
  vertex_loader = new THREE.XHRLoader(THREE.DefaultLoadingManager);
  vertex_loader.setResponseType('text');
  return vertex_loader.load(vertex_url, (function(vertex_text) {
    var fragment_loader;
    fragment_loader = new THREE.XHRLoader(THREE.DefaultLoadingManager);
    fragment_loader.setResponseType('text');
    return fragment_loader.load(fragment_url, function(fragment_text) {
      return onLoad(vertex_text, fragment_text);
    });
  }), onProgress, onError);
};

rnd = function(r) {
  return (Math.random() - Math.random()) * r / 2.0;
};

environment = [];

lights = [];

create_evironment = function() {
  var f, i, materials, plane, textureLoader, white_mat, _i, _results;
  textureLoader = new THREE.TextureLoader;
  materials = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 1; _i <= 4; i = ++_i) {
      _results.push(new THREE.MeshBasicMaterial({
        color: 0xffffff,
        map: textureLoader.load("res/txt" + i + ".jpg")
      }));
    }
    return _results;
  })();
  white_mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    side: THREE.DoubleSide
  });
  _results = [];
  for (f = _i = 0; _i <= 10; f = ++_i) {
    switch (f % 3) {
      case 0:
        plane = new THREE.Mesh(new THREE.PlaneGeometry(800, 600, 1, 1), materials[f % 4]);
        plane.position.set(rnd(L), 300, 200 + rnd(100));
        plane.rotateX(Math.PI);
        break;
      case 1:
        plane = new THREE.Mesh(new THREE.PlaneGeometry(800, 600, 1, 1), materials[f % 4]);
        plane.position.set(rnd(L), 300, -200 + rnd(100));
        break;
      case 2:
        plane = new THREE.Mesh(new THREE.CircleGeometry(20 + rnd(50), 16), white_mat);
        plane.rotateX(Math.PI / 2.0);
        plane.position.set(rnd(L), 200 + rnd(100), rnd(800));
    }
    plane.visible = false;
    scene.add(plane);
    _results.push(environment.push(plane));
  }
  return _results;
};

init = function() {
  var cube_mat, cube_shader, normalMap, skymaterial, skyshader, sphere_mat, uniforms;
  renderer = new THREE.WebGLRenderer;
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(WIDTH, HEIGHT);
  document.body.appendChild(renderer.domElement);
  scene = new THREE.Scene;
  camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 100000);
  camera.position.z = 500;
  c_camera = new THREE.CubeCamera(1, 1000, 256);
  c_camera.rotateY(Math.PI);
  c_camera.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
  scene.add(c_camera);
  skyshader = THREE.ShaderLib['cube'];
  skyshader.uniforms['tCube'].value = c_camera.renderTarget.texture;
  skymaterial = new THREE.ShaderMaterial({
    fragmentShader: skyshader.fragmentShader,
    vertexShader: skyshader.vertexShader,
    uniforms: skyshader.uniforms,
    depthWrite: false,
    side: THREE.BackSide
  });
  sky = new THREE.Mesh(new THREE.BoxGeometry(400, 400, 400), skymaterial);
  sky.visible = false;
  scene.add(sky);
  controls = new THREE.TrackballControls(camera, renderer.domElement);
  normalMap = THREE.ImageUtils.loadTexture('res/car_normal.png', null, function(something) {
    return render();
  });
  uniforms = {
    paintColor1: {
      type: 'c',
      value: new THREE.Color(0x002f66)
    },
    paintColor2: {
      type: 'c',
      value: new THREE.Color(0x002c99)
    },
    paintColor3: {
      type: 'c',
      value: new THREE.Color(0x276296)
    },
    normalMap: {
      type: 't',
      value: normalMap
    },
    normalScale: {
      type: 'f',
      value: 0.0,
      min: 0.0,
      max: 1.0
    },
    glossLevel: {
      type: 'f',
      value: 1.0,
      min: 0.0,
      max: 5.0
    },
    brightnessFactor: {
      type: 'f',
      value: 1.0,
      min: 0.0,
      max: 1.0
    },
    envMap: {
      type: 't',
      value: c_camera.renderTarget.texture
    },
    microflakeNMap: {
      type: 't',
      value: THREE.ImageUtils.loadTexture('res/SparkleNoiseMap.png')
    },
    flakeColor: {
      type: 'c',
      value: new THREE.Color(0xFFFFFF)
    },
    flakeScale: {
      type: 'f',
      value: -30.0,
      min: -50.0,
      max: 1.0
    },
    normalPerturbation: {
      type: 'f',
      value: 1.0,
      min: -1.0,
      max: 1.0
    },
    microflakePerturbationA: {
      type: 'f',
      value: 0.1,
      min: -1.0,
      max: 1.0
    },
    microflakePerturbation: {
      type: 'f',
      value: 0.48,
      min: 0.0,
      max: 1.0
    }
  };
  uniforms.microflakeNMap.value.wrapS = uniforms.microflakeNMap.value.wrapT = THREE.RepeatWrapping;
  shader_loader('res/carpaint.vert', 'res/carpaint.frag', function(vert, frag) {
    var loader;
    carpaint_mat = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: vert,
      fragmentShader: frag,
      side: THREE.DoubleSide,
      derivatives: true
    });
    loader = new THREE.OBJLoader;
    return loader.load('res/bmw.obj', function(object) {
      car = object.children[0];
      car.material = carpaint_mat;
      scene.add(car);
      return render();
    });
  });
  cube_shader = THREE.ShaderLib["cube"];
  cube_mat = new THREE.ShaderMaterial({
    fragmentShader: cube_shader.fragmentShader,
    vertexShader: cube_shader.vertexShader,
    uniforms: cube_shader.uniforms,
    depthWrite: false,
    side: THREE.BackSide
  });
  cube_mat.uniforms["tCube"].value = c_camera.renderTarget.texture;
  sphere_mat = new THREE.MeshBasicMaterial({
    envMap: c_camera.renderTarget.texture
  });
  sphere_mesh = new THREE.Mesh(new THREE.SphereBufferGeometry(30.0, 48, 24), sphere_mat);
  sphere_mesh.position.z = -100;
  scene.add(sphere_mesh);
  create_evironment();
  stats = new Stats;
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.bottom = '0px';
  document.body.appendChild(stats.domElement);
  setupControls(uniforms);
  return window.addEventListener('resize', onWindowResize, false);
};

onWindowResize = function() {
  camera.aspect = WIDTH / HEIGHT;
  camera.updateProjectionMatrix();
  renderer.setSize(WIDTH, HEIGHT);
  controls.handleResize();
  return render();
};

animate = function() {
  var e, _i, _len;
  for (_i = 0, _len = environment.length; _i < _len; _i++) {
    e = environment[_i];
    e.position.x += 10.0;
    if (e.position.x > L / 2.0) {
      e.position.x = -L / 2.0;
    }
  }
  requestAnimationFrame(animate);
  controls.update();
  return render();
};

render = function() {
  var e, _i, _j, _len, _len1;
  if (car != null) {
    car.visible = false;
  }
  if (sphere_mesh != null) {
    sphere_mesh.visible = false;
  }
  for (_i = 0, _len = environment.length; _i < _len; _i++) {
    e = environment[_i];
    if (e != null) {
      e.visible = true;
    }
  }
  c_camera.update(renderer, scene);
  if (car != null) {
    car.visible = true;
  }
  if (sphere_mesh != null) {
    sphere_mesh.visible = true;
  }
  for (_j = 0, _len1 = environment.length; _j < _len1; _j++) {
    e = environment[_j];
    if (e != null) {
      e.visible = false;
    }
  }
  renderer.render(scene, camera);
  return stats != null ? stats.update() : void 0;
};

setupControls = function(ob) {
  var butob, buttons, controller, disable_btn, dwn_btn, enable_btn, grabber, gui, key, rec_btn, sceneFolder, sourceFolder, stp_btn, uniformsFolder;
  gui = new dat.GUI;
  disable_btn = function(btn) {
    var bs;
    bs = btn.domElement.parentElement.style;
    bs.pointerEvents = "none";
    return bs.opacity = .2;
  };
  enable_btn = function(btn) {
    var bs;
    bs = btn.domElement.parentElement.style;
    bs.pointerEvents = null;
    return bs.opacity = null;
  };
  grabber = new video_grabber(renderer.context.canvas);
  buttons = {
    record: function() {
      disable_btn(rec_btn);
      enable_btn(stp_btn);
      return grabber != null ? grabber.start_recording() : void 0;
    },
    stop: function() {
      disable_btn(stp_btn);
      enable_btn(rec_btn);
      enable_btn(dwn_btn);
      return grabber != null ? grabber.stop_recording() : void 0;
    },
    download: function() {
      return grabber.download();
    }
  };
  rec_btn = gui.add(buttons, "record");
  stp_btn = gui.add(buttons, "stop");
  dwn_btn = gui.add(buttons, "download");
  disable_btn(stp_btn);
  disable_btn(dwn_btn);
  sceneFolder = gui.addFolder('Scene');
  sceneFolder.add(sky, 'visible').name('Show Cubemap').onChange(function() {
    return render();
  });
  sceneFolder.open();
  uniformsFolder = gui.addFolder('Uniforms');
  for (key in ob) {
    if (ob[key].type === 'f') {
      controller = uniformsFolder.add(ob[key], 'value').name(key);
      if (typeof ob[key].min !== 'undefined') {
        controller = controller.min(ob[key].min).name(key);
      }
      if (typeof ob[key].max !== 'undefined') {
        controller = controller.max(ob[key].max).name(key);
      }
      controller.onChange(function(value) {
        this.object.value = parseFloat(value);
        return render();
      });
    } else if (ob[key].type === 'c') {
      ob[key].guivalue = [ob[key].value.r * 255, ob[key].value.g * 255, ob[key].value.b * 255];
      controller = uniformsFolder.addColor(ob[key], 'guivalue').name(key);
      controller.onChange(function(value) {
        this.object.value.setRGB(value[0] / 255, value[1] / 255, value[2] / 255);
        return render();
      });
    }
  }
  uniformsFolder.open();
  sourceFolder = gui.addFolder('Source');
  butob = {
    'view vertex shader code': function() {
      TINY.box.show;
      return {
        html: '<div style="width: 500px; height: 500px;"><h3 style="margin: 0px; padding-bottom: 5px;">Vertex Shader</h3><pre style="overflow: scroll; height: 470px;">' + document.getElementById('vertexShader').text + '</pre></div>',
        animate: false,
        close: false,
        top: 5
      };
    },
    'view fragment shader code': function() {
      TINY.box.show;
      return {
        html: '<div style="width: 500px; height: 500px;"><h3 style="margin: 0px; padding-bottom: 5px;">Fragment Shader</h3><pre style="overflow: scroll; height: 470px;">' + document.getElementById('fragmentShader').text + '</pre></div>',
        animate: false,
        close: false,
        top: 5
      };
    }
  };
  sourceFolder.add(butob, 'view vertex shader code');
  return sourceFolder.add(butob, 'view fragment shader code');
};

init();

animate();
